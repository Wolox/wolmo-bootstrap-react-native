<%_ if(features.animatedcustomtextinput){ _%>
 import React, { useState, useCallback, useEffect, memo, useRef } from 'react';
import { View, TextInput, TextProps, ViewProps, TextInputProps, Animated, TextStyle } from 'react-native';
import CustomText from '@components/CustomText';
import { transparent, gray, black } from '@constants/colors';

import ShowPassword from './components/ShowPassword';
import styles from './styles';

interface Props extends TextInputProps, TextProps {
  bottomBorder?: boolean;
  underlineColorAndroid?: string;
  maxHeight?: number;
  autoCorrect?: boolean;
  multiline?: boolean;
  placeholder?: string;
  textStyles?: TextStyle;
  onBlur?: TextInputProps['onBlur'];
  onChange?(e: any): any;
  onFocus?: TextInputProps['onFocus'];
  value?: string;
  placeholderTextColor?: string;
  showEye?: boolean;
  secureTextEntry?: boolean;
  istitle?: boolean;
  style?: ViewProps['style'];
  label?: string;
  labelStyle?: TextProps['style'];
  autoCompleteType?: TextInputProps['autoCompleteType'];
  error?: boolean | string;
  disabled?: boolean;
}

const TOP_DEGRADE = -25;
const LABEL_SIZE = 14;
const LABEL_SIZE_DEGRADE = 12;
const LEFT_DEGRADE = 5;
const LEFT_SMALL_DEGRADE = 0;
const CustomTextInput = (props: Props): JSX.Element => {
  const {
    value,
    placeholderTextColor,
    multiline,
    bottomBorder,
    style,
    textStyles,
    secureTextEntry,
    showEye,
    label,
    labelStyle,
    placeholder,
    error,
    disabled,
    onFocus,
    onBlur,
    onChange,
    autoCompleteType,
    ...rest
  } = props;
  const [showPassword, setShowPassword] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const animatedIsFocused = useRef(new Animated.Value(value ? 1 : 0)).current;
  let inputRef: TextInput | null = null;
  const handlePressEdit = () => inputRef!.focus();
  useEffect(() => {
    const realValue = isFocused || value ? 1 : 0;
    Animated.timing(animatedIsFocused, {
      toValue: realValue,
      duration: 200
    }).start();
  }, [animatedIsFocused, isFocused, value]);

  const handleShowPassword = useCallback(() => setShowPassword(prevShowPassword => !prevShowPassword), []);

  const handleFocus = useCallback(
    e => {
      setIsFocused(true);
      if (onFocus) onFocus(e);
    },
    [onFocus]
  );

  const animatedLabelStyle = {
    top: animatedIsFocused.interpolate({
      inputRange: [0, 1],
      outputRange: [0, TOP_DEGRADE]
    }),
    left: animatedIsFocused.interpolate({
      inputRange: [0, 1],
      outputRange: [LEFT_DEGRADE, LEFT_SMALL_DEGRADE]
    }),
    fontSize: animatedIsFocused.interpolate({
      inputRange: [0, 1],
      outputRange: [LABEL_SIZE, LABEL_SIZE_DEGRADE]
    }),
    color: animatedIsFocused.interpolate({
      inputRange: [0, 1],
      outputRange: [gray, black]
    })
  };

  const handleBlur = useCallback(
    e => {
      setIsFocused(false);
      if (onBlur) onBlur(e);
    },
    [onBlur]
  );

  const placeholderColor = value ? transparent : placeholderTextColor;
  const borderStyle = () => {
    if (disabled) return styles.bottomBorderLightGray;
    if (isFocused) return styles.bottomBorderBlue;
    if (error) return styles.bottomBorderRed;
    return styles.bottomBorderGray;
  };
  return (
    <View style={[(label && styles.containerWithLabel) as undefined | Record<string, any>, style]}>
      {label && (
        <Animated.Text allowFontScaling={false} style={[styles.label, animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      )}
      <View style={[!multiline && styles.inputContainer, bottomBorder && borderStyle()]}>
        <TextInput
          {...rest}
          value={value}
          allowFontScaling={false}
          onChangeText={onChange}
          onBlur={handleBlur}
          onFocus={handleFocus}
          style={[
            styles.inputStyle,
            !multiline && styles.singleInput,
            !multiline && styles.offset,
            textStyles
          ]}
          multiline={multiline}
          placeholderTextColor={placeholderColor}
          secureTextEntry={secureTextEntry && !showPassword}
          autoCompleteType={secureTextEntry ? 'off' : autoCompleteType}
          placeholder={isFocused && value === '' ? placeholder : ''}
          editable={!disabled}
          ref={ref => (inputRef = ref)}
        />
        {secureTextEntry && showEye && (
          <ShowPassword onShowPassword={handleShowPassword} passwordVisible={showPassword} />
        )}
      </View>
      {error && (
        <CustomText error xsmall style={styles.errorMessage}>
          {error}
        </CustomText>
      )}
    </View>
  );
};

CustomTextInput.defaultProps = {
  autoCapitalize: 'none',
  autoCompleteType: 'off',
  autoCorrect: false,
  bottomBorder: true,
  clearButtonMode: 'never',
  disabled: false,
  keyboardType: 'default',
  maxHeight: 200,
  multiline: false,
  placeholder: '',
  returnKeyType: 'done',
  underlineColorAndroid: transparent
};

const MyCustomTextInput = memo(CustomTextInput);

export default MyCustomTextInput;

<%_ } _%>
<%_ if(!features.animatedcustomtextinput){_%>
import React, { useState, useCallback, memo } from 'react';
import { View, TextInput, Text } from 'react-native';
import PropTypes from 'prop-types';
import CustomText from '@components/CustomText';
import { transparent } from '@constants/colors';

import ShowPassword from './components/ShowPassword';
import styles from './styles';

const CustomTextInput = props => {
  const [showPassword, setShowPassword] = useState(false);

  const handleShowPassword = useCallback(() => setShowPassword(prevShowPassword => !prevShowPassword), []);

  const {
    value,
    placeholderTextColor,
    title,
    titleStyles,
    multiline,
    bottomBorder,
    style,
    onChange,
    onBlur,
    onFocus,
    textStyles,
    secureTextEntry,
    showEye,
    autoCompleteType
  } = props;

  const placeholderColor = value ? transparent : placeholderTextColor;

  return (
    <>
      {title && (
        <CustomText gray small style={[styles.title, titleStyles]}>
          {title}
        </CustomText>
      )}
      <View
        style={[
          multiline ? styles.multilineContainer : styles.container,
          bottomBorder && styles.bottomBorder,
          style
        ]}
      >
        <TextInput
          {...props}
          allowFontScaling={false}
          onChangeText={onChange}
          onBlur={onBlur}
          onFocus={onFocus}
          value={value}
          style={[styles.inputStyle, multiline ? styles.multilineInput : styles.singleInput, textStyles]}
          placeholderTextColor={placeholderColor}
          secureTextEntry={secureTextEntry && !showPassword}
          autoCompleteType={secureTextEntry ? 'off' : autoCompleteType}
        />
        {secureTextEntry && showEye && (
          <ShowPassword onShowPassword={handleShowPassword} passwordVisible={showPassword} />
        )}
      </View>
    </>
  );
};

CustomTextInput.defaultProps = {
  autoCapitalize: 'sentences',
  autoCorrect: false,
  bottomBorder: false,
  clearButtonMode: 'never',
  keyboardType: 'default',
  maxHeight: 200,
  multiline: false,
  returnKeyType: 'done',
  underlineColorAndroid: transparent
};

CustomTextInput.propTypes = {
  autoCapitalize: PropTypes.oneOf(['none', 'sentences', 'words', 'characters']),
  autoComplete: PropTypes.string,
  autoCompleteType: PropTypes.string,
  autoCorrect: PropTypes.bool,
  bottomBorder: PropTypes.bool,
  clearButtonMode: PropTypes.oneOf(['never', 'while-editing', 'unless-editing', 'always']),
  keyboardType: PropTypes.oneOf(['default', 'numeric', 'email-address', 'phone-pad']),
  maxHeight: PropTypes.number,
  multiline: PropTypes.bool,
  placeholder: PropTypes.string,
  placeholderTextColor: PropTypes.string,
  returnKeyType: PropTypes.oneOf(['done', 'go', 'next', 'search']),
  secureTextEntry: PropTypes.bool,
  showEye: PropTypes.bool,
  textStyles: Text.propTypes.style,
  title: PropTypes.string,
  titleStyles: Text.propTypes.style,
  underlineColorAndroid: PropTypes.string,
  value: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  onFocus: PropTypes.func
};

export default memo(CustomTextInput);

<%_ } _%>